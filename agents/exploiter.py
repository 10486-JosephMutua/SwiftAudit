import json
from typing import List, Optional
from datetime import datetime

from core.config import config
from core.logger import get_logger
from core.models import (
    VulnerabilityFinding, ExploitPath, ExploitStep, Severity, DetectionSource
)
from tools.security_tools import EXPLOITER_TOOLS
from utils.llm_client import invoke_agent_with_fallback
from utils.llm_providers import get_primary_name

logger = get_logger("agents.exploiter")


class ExploiterAgent:
    """
    Red Team Simulation Agent.

    Generates step-by-step attacker simulations for high-severity findings.
    Prioritizes tool-detected findings (higher confidence = more valuable simulation).
    """

    def __init__(self):
        # No LLM stored — invoke_agent_with_fallback() manages provider
        # selection and failover at call time.
        self._primary_name = get_primary_name()
        logger.info(
            f"[EXPLOITER] ExploiterAgent v7 initialized | "
            f"primary provider: {self._primary_name} | "
            f"fallback chain active"
        )

    def run(self, findings: List[VulnerabilityFinding]) -> List[VulnerabilityFinding]:
        """
        Generate exploit paths for high-value findings.

        Priority order:
        1. Tool-detected CRITICAL findings
        2. Tool-detected HIGH findings
        3. LLM-detected CRITICAL findings
        4. LLM-detected HIGH findings (if budget allows)
        """
        logger.info(f"[EXPLOITER] ⚔️  Starting exploit simulation: {len(findings)} findings")
        start_time = datetime.now()

        # Sort: tool-detected first, then by severity
        severity_order = {
            Severity.CRITICAL: 0, Severity.HIGH: 1,
            Severity.MEDIUM: 2, Severity.LOW: 3, Severity.INFO: 4
        }
        tool_sources = {
            DetectionSource.BANDIT, DetectionSource.SEMGREP,
            DetectionSource.DETECT_SECRETS, DetectionSource.SAFETY,
            DetectionSource.LLM_ENRICHED
        }

        def priority_key(f: VulnerabilityFinding) -> tuple:
            is_tool = 0 if f.detection_source in tool_sources else 1
            sev = severity_order.get(Severity(f.severity), 5)
            return (is_tool, sev)

        # Only CRITICAL and HIGH get exploit simulations
        targets = [
            f for f in findings
            if f.severity in (
                Severity.CRITICAL, Severity.HIGH,
                "CRITICAL", "HIGH"
            )
        ]
        targets.sort(key=priority_key)

        # v10 FIX: cap at 10 findings — LLM call per finding is expensive
        # Tool-detected first (already sorted), then CRITICAL LLM, then HIGH LLM
        MAX_EXPLOITS = 10
        if len(targets) > MAX_EXPLOITS:
            logger.info(
                f"[EXPLOITER] Capping exploits: {len(targets)} → {MAX_EXPLOITS} "
                f"(tool-detected + highest severity first)"
            )
            targets = targets[:MAX_EXPLOITS]

        logger.info(f"[EXPLOITER] Targets for simulation: {len(targets)} (cap={MAX_EXPLOITS})")

        for i, finding in enumerate(targets):
            logger.info(
                f"[EXPLOITER] Simulating {i+1}/{len(targets)}: "
                f"'{finding.title}' | {finding.detection_source}"
            )

            initial_messages = [{
                "role": "user",
                "content": (
                    f"Use the generate_exploit_path tool to create an attacker "
                    f"simulation for this CONFIRMED vulnerability.\n"
                    f"Title: {finding.title}\n"
                    f"Severity: {finding.severity}\n"
                    f"Description: {finding.description[:300]}\n"
                    f"File: {finding.file_path}\n"
                    f"Code: {finding.code_snippet[:800]}\n"
                    f"Detection Source: {finding.detection_source}\n\n"
                    f"Call generate_exploit_path with vulnerability_title, "
                    f"vulnerability_description, code_snippet, file_path, severity."
                )
            }]

            try:
                result = invoke_agent_with_fallback(
                    tools=EXPLOITER_TOOLS,
                    initial_messages=initial_messages,
                    label=f"exploiter_{i+1}of{len(targets)}",
                )

                exploit_data = self._extract_tool_output(result)
                if not exploit_data:
                    logger.warning(f"[EXPLOITER] No exploit data for: {finding.title}")
                    continue

                try:
                    parsed = json.loads(exploit_data)
                except json.JSONDecodeError:
                    logger.warning(f"[EXPLOITER] JSON parse failed for: {finding.title}")
                    continue

                steps = []
                for s in parsed.get("steps", []):
                    steps.append(ExploitStep(
                        step_number=s.get("step_number", len(steps) + 1),
                        action=s.get("action", ""),
                        target=s.get("target", ""),
                        result=s.get("result", ""),
                    ))

                exploit_path = ExploitPath(
                    title=parsed.get("title", f"Exploit: {finding.title}"),
                    prerequisites=parsed.get("prerequisites", []),
                    steps=steps,
                    impact=parsed.get("impact", ""),
                    difficulty=parsed.get("difficulty", "MEDIUM"),
                    attacker_type=parsed.get("attacker_type", "Skilled Attacker"),
                    proof_of_concept=parsed.get("proof_of_concept", ""),
                    poc_verified=parsed.get("poc_verified", False),
                )

                finding.exploit_path = exploit_path

                poc_status = "✅ verified" if exploit_path.poc_verified else "⚠️  unverified"
                logger.info(
                    f"[EXPLOITER] ✅ '{finding.title}': "
                    f"{len(steps)} steps | PoC {poc_status}"
                )

            except Exception as e:
                logger.error(f"[EXPLOITER] Failed for '{finding.title}': {e}")

        elapsed = (datetime.now() - start_time).total_seconds()
        exploited = sum(1 for f in findings if f.exploit_path is not None)
        logger.info(
            f"[EXPLOITER] ✅ Complete in {elapsed:.2f}s | "
            f"{exploited} exploit paths generated"
        )

        return findings

    def _extract_tool_output(self, agent_result: dict) -> Optional[str]:
        messages = agent_result.get("messages", [])
        for msg in reversed(messages):
            msg_type = getattr(msg, "__class__", type(msg)).__name__
            content = getattr(msg, "content", "")
            if "ToolMessage" in msg_type and content:
                return content
        return None
